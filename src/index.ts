import fetch from "node-fetch"
import {
    AccountMeta,
    Connection,
    Keypair,
    PublicKey,
    Transaction,
    clusterApiUrl,
    sendAndConfirmTransaction,
} from "@solana/web3.js"
import {
    airdropSolIfNeeded,
    createNftMetadata,
    CollectionDetails,
    getOrCreateCollectionNFT,
} from "./utils"
import {
    SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    ValidDepthSizePair,
    createAllocTreeIx,
    SPL_NOOP_PROGRAM_ID,
    ConcurrentMerkleTreeAccount,
} from "@solana/spl-account-compression"
import {
    PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,
    createCreateTreeInstruction,
    createMintToCollectionV1Instruction,
    createTransferInstruction,
    getLeafAssetId,
} from "@metaplex-foundation/mpl-bubblegum"
import { PROGRAM_ID as TOKEN_METADATA_PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata"
// import { BN } from "@project-serum/anchor"
import { base58 } from '@metaplex-foundation/umi/serializers';
import dotenv from "dotenv"
dotenv.config()

async function main() {
    if (!process.env?.PAYER_SECRET_KEY) {
        throw new Error("Missing Payer Secret Key .env variable")
    }

    const connection = new Connection(clusterApiUrl("devnet"), "confirmed")

    const secretKey = base58.serialize(process.env?.PAYER_SECRET_KEY)
    const wallet = Keypair.fromSecretKey(secretKey)

    console.log("Payer address:", wallet.publicKey.toBase58());
    airdropSolIfNeeded(wallet.publicKey)

    const maxDepthSizePair: ValidDepthSizePair = {
        maxDepth: 3,
        maxBufferSize: 8,
    }

    const canopyDepth = 0

    const treeAddress = await createAndInitializeTree(
        connection,
        wallet,
        maxDepthSizePair,
        canopyDepth
    )

    const collectionNft = await getOrCreateCollectionNFT(connection, wallet)

    await mintCompressedNftToCollection(
        connection,
        wallet,
        treeAddress,
        collectionNft,
        2 ** maxDepthSizePair.maxDepth
    )

    // Log NFT details to illustrate Read API
    // await logNftDetails(treeAddress, 2 ** maxDepthSizePair.maxDepth)

    // const receiver = new PublicKey(wallet.publicKey.toBase58())

    // // Transfer first cNFT to random receiver to illustrate transfers
    // await transferNft(
    //     connection,
    //     await getLeafAssetId(treeAddress, new BN(0)),
    //     wallet,
    //     receiver
    // )
}

async function createAndInitializeTree(
    connection: Connection,
    payer: Keypair,
    maxDepthSizePair: ValidDepthSizePair,
    canopyDepth: number
) {
    const treeKeypair = Keypair.generate()
    const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(
        [treeKeypair.publicKey.toBuffer()],
        BUBBLEGUM_PROGRAM_ID
    )
    const allocTreeIx = await createAllocTreeIx(
        connection,
        treeKeypair.publicKey,
        payer.publicKey,
        maxDepthSizePair,
        canopyDepth
    )
    const createTreeIx = createCreateTreeInstruction(
        {
            treeAuthority,
            merkleTree: treeKeypair.publicKey,
            payer: payer.publicKey,
            treeCreator: payer.publicKey,
            logWrapper: SPL_NOOP_PROGRAM_ID,
            compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        },
        {
            maxBufferSize: maxDepthSizePair.maxBufferSize,
            maxDepth: maxDepthSizePair.maxDepth,
            public: false,
        }
    )

    const tx = new Transaction().add(allocTreeIx, createTreeIx)
    tx.feePayer = payer.publicKey

    try {
        const txSignature = await sendAndConfirmTransaction(
            connection,
            tx,
            [treeKeypair, payer],
            {
                commitment: "finalized",
                skipPreflight: true,
            }
        )

        console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)

        console.log("Tree Address:", treeKeypair.publicKey.toBase58())

        return treeKeypair.publicKey
    } catch (err: any) {
        console.error("\nFailed to create merkle tree:", err)
        throw err
    }
}

async function mintCompressedNftToCollection(
    connection: Connection,
    payer: Keypair,
    treeAddress: PublicKey,
    collectionDetails: CollectionDetails,
    amount: number
) {
    // Derive the tree authority PDA ('TreeConfig' account for the tree account)
    const [treeAuthority] = PublicKey.findProgramAddressSync(
        [treeAddress.toBuffer()],
        BUBBLEGUM_PROGRAM_ID
    )

    // Derive the bubblegum signer, used by the Bubblegum program to handle "collection verification"
    // Only used for `createMintToCollectionV1` instruction
    const [bubblegumSigner] = PublicKey.findProgramAddressSync(
        [Buffer.from("collection_cpi", "utf8")],
        BUBBLEGUM_PROGRAM_ID
    )

    for (let i = 0; i < amount; i++) {
        // Compressed NFT Metadata
        const compressedNFTMetadata = createNftMetadata(payer.publicKey, i, collectionDetails.mint)

        // Create the instruction to "mint" the compressed NFT to the tree
        const mintIx = createMintToCollectionV1Instruction(
            {
                payer: payer.publicKey, // The account that will pay for the transaction
                merkleTree: treeAddress, // The address of the tree account
                treeAuthority, // The authority of the tree account, should be a PDA derived from the tree account address
                treeDelegate: payer.publicKey, // The delegate of the tree account, should be the same as the tree creator by default
                leafOwner: payer.publicKey, // The owner of the compressed NFT being minted to the tree
                leafDelegate: payer.publicKey, // The delegate of the compressed NFT being minted to the tree
                collectionAuthority: payer.publicKey, // The authority of the "collection" NFT
                collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID, // Must be the Bubblegum program id
                collectionMint: collectionDetails.mint, // The mint of the "collection" NFT
                collectionMetadata: collectionDetails.metadata, // The metadata of the "collection" NFT
                editionAccount: collectionDetails.masterEditionAccount, // The master edition of the "collection" NFT
                compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
                logWrapper: SPL_NOOP_PROGRAM_ID,
                bubblegumSigner,
                tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
            },
            {
                metadataArgs: Object.assign(compressedNFTMetadata, {
                    collection: { key: collectionDetails.mint, verified: false },
                }),
            }
        )

        try {
            // Create new transaction and add the instruction
            const tx = new Transaction().add(mintIx)

            // Set the fee payer for the transaction
            tx.feePayer = payer.publicKey

            // Send the transaction
            const txSignature = await sendAndConfirmTransaction(
                connection,
                tx,
                [payer],
                { commitment: "finalized", skipPreflight: true }
            )

            console.log(
                `https://explorer.solana.com/tx/${txSignature}?cluster=devnet`
            )
        } catch (err) {
            console.error("\nFailed to mint compressed NFT:", err)
            throw err
        }
    }
}

// async function logNftDetails(treeAddress: PublicKey, nftsMinted: number) {
//     if (!process.env.RPC_URL) {
//         throw new Error("Missing RPC_URL Enviroment variable")
//     }
//     for (let i = 0; i < nftsMinted; i++) {
//         const assetId = await getLeafAssetId(treeAddress, new BN(i))
//         console.log("Asset ID:", assetId.toBase58())
//         const response = await fetch(process.env.RPC_URL, {
//             method: "POST",
//             headers: { "Content-Type": "application/json" },
//             body: JSON.stringify({
//                 jsonrpc: "2.0",
//                 id: "my-id",
//                 method: "getAsset",
//                 params: {
//                     id: assetId,
//                 },
//             }),
//         })
//         const { result } = await response.json() as any
//         console.log(JSON.stringify(result, null, 2))
//     }
// }

async function transferNft(
    connection: Connection,
    assetId: PublicKey,
    sender: Keypair,
    receiver: PublicKey
) {
    if (!process.env.RPC_URL) {
        throw new Error("Missing RPC_URL Enviroment variable")
    }
    try {
        const assetDataResponse = await fetch(process.env.RPC_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: "my-id",
                method: "getAsset",
                params: {
                    id: assetId,
                },
            }),
        })
        const assetData = (await assetDataResponse.json() as any).result

        const assetProofResponse = await fetch(process.env.RPC_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: "my-id",
                method: "getAssetProof",
                params: {
                    id: assetId,
                },
            }),
        })
        const assetProof = (await assetProofResponse.json() as any).result

        const treePublicKey = new PublicKey(assetData.compression.tree)

        const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
            connection,
            treePublicKey
        )

        const canopyDepth = treeAccount.getCanopyDepth() || 0

        const proofPath: AccountMeta[] = assetProof.proof
            .map((node: string) => ({
                pubkey: new PublicKey(node),
                isSigner: false,
                isWritable: false,
            }))
            .slice(0, assetProof.proof.length - canopyDepth)

        const treeAuthority = treeAccount.getAuthority()
        const leafOwner = new PublicKey(assetData.ownership.owner)
        const leafDelegate = assetData.ownership.delegate
            ? new PublicKey(assetData.ownership.delegate)
            : leafOwner

        const transferIx = createTransferInstruction(
            {
                merkleTree: treePublicKey,
                treeAuthority,
                leafOwner,
                leafDelegate,
                newLeafOwner: receiver,
                logWrapper: SPL_NOOP_PROGRAM_ID,
                compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
                anchorRemainingAccounts: proofPath,
            },
            {
                root: [...new PublicKey(assetProof.root.trim()).toBytes()],
                dataHash: [
                    ...new PublicKey(assetData.compression.data_hash.trim()).toBytes(),
                ],
                creatorHash: [
                    ...new PublicKey(assetData.compression.creator_hash.trim()).toBytes(),
                ],
                nonce: assetData.compression.leaf_id,
                index: assetData.compression.leaf_id,
            }
        )

        const tx = new Transaction().add(transferIx)
        tx.feePayer = sender.publicKey
        const txSignature = await sendAndConfirmTransaction(
            connection,
            tx,
            [sender],
            {
                commitment: "confirmed",
                skipPreflight: true,
            }
        )
        console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)
    } catch (err: any) {
        console.error("\nFailed to transfer nft:", err)
        throw err
    }
}

main()